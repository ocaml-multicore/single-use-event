<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Single_use_event (single-use-event.Single_use_event)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">single-use-event</a> &#x00BB; Single_use_event</nav><header class="odoc-preamble"><h1>Module <code><span>Single_use_event</span></code></h1><p>A scheduler independent blocking mechnanism.</p><p>This is designed as a low level mechanism intended for writing higher level libraries that need to block in a scheduler friendly manner.</p><p>A library that needs to suspend and later resume the current thread of execution can <a href="#val-create"><code>create</code></a> a single use event, arrange <a href="#val-signal"><code>signal</code></a> to be called on it, and <a href="#val-await"><code>await</code></a> for the call.</p><p>To provide an efficient and scheduler friendly implementation of the mechanism, schedulers may handle the <a href="#extension-Await"><code>Await</code></a> effect.</p><p>This mechanism is designed to be minimalistic, safe, and allow for efficient use and implementations:</p><ul><li>The only place to handle cancellation is at the point of calling <a href="#val-await"><code>await</code></a>, which may raise an exception to signal cancellation. The caller must then take care to clean up.</li></ul><ul><li>This mechanism intentionally does not provide a way to communicate any result with the signal. That can easily be done outside of the mechanism.</li></ul><ul><li>This mechanism is entirely first-order. A handler for the <a href="#extension-Await"><code>Await</code></a> effect does not need to call arbitrary code outside of the scheduler implementation. Both the scheduler side and the user side are only responsible for their own safety concerns.</li></ul></header><nav class="odoc-toc"><ul><li><a href="#interface-for-suspending">Interface for suspending</a></li><li><a href="#interface-for-resuming">Interface for resuming</a></li><li><a href="#interface-for-schedulers">Interface for schedulers</a></li></ul></nav><div class="odoc-content"><h3 id="interface-for-suspending"><a href="#interface-for-suspending" class="anchor"></a>Interface for suspending</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Represents a single use event. A single use event can be in one of three states in order:</p><p>1. initial, 2. attached, and 3. signaled.</p><p>The state of a single use event can only advance monotonically.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create ()</code> allocates a new single use event in the initial state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_signaled"><a href="#val-is_signaled" class="anchor"></a><code><span><span class="keyword">val</span> is_signaled : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_signaled sue</code> determines whether the single use event <code>sue</code> is in the signaled state.</p><p>This can be used to poll the state of a single use event and avoid work, but this should not be used as a substitute for <a href="#val-await"><code>await</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await"><a href="#val-await" class="anchor"></a><code><span><span class="keyword">val</span> await : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>await sue</code> waits for the single use event <code>sue</code> to be set to the signaled state. <code>await sue</code> must be called at most once per single use event <code>sue</code>.</p><p>Instead of returning, <code>await sue</code> may raise an exception to signal cancellation. In either case the caller of <code>await sue</code> is responsible for cleaning up. Usually this means making sure that no references to the single use event <code>sue</code> remain to avoid space leaks.</p></div></div><h3 id="interface-for-resuming"><a href="#interface-for-resuming" class="anchor"></a>Interface for resuming</h3><div class="odoc-spec"><div class="spec value anchored" id="val-signal"><a href="#val-signal" class="anchor"></a><code><span><span class="keyword">val</span> signal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>After <code>signal sue</code> returns, the single use event <code>sue</code> will be in the signaled state. If the single use event <code>sue</code> was in the attached state, the attached action will be called.</p></div></div><h3 id="interface-for-schedulers"><a href="#interface-for-schedulers" class="anchor"></a>Interface for schedulers</h3><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Await"><a href="#extension-decl-Await" class="anchor"></a><code><span><span class="keyword">type</span> <span class="xref-unresolved">Stdlib</span>.Effect.t += </span></code><ol><li id="extension-Await" class="def extension anchored"><a href="#extension-Await" class="anchor"></a><code><span>| </span><span><span class="extension">Await</span> : <a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span> <span>unit <span class="xref-unresolved">Stdlib</span>.Effect.t</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Await sue</code> effect may be performed by <code>await sue</code> to await for the single use event <code>sue</code> to be set to the signaled state.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p><code>Effect.t</code> was added in OCaml 5.0. Under older versions of OCaml <a href="#val-await"><code>await</code></a> uses a <code>Mutex</code> and a <code>Condition</code> variable and there is no way to customize the behavior.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-try_attach"><a href="#val-try_attach" class="anchor"></a><code><span><span class="keyword">val</span> try_attach : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>try_attach sue action</code> tries to set the single use event <code>sue</code> to the attached state, which can only succeed if <code>sue</code> was in the initial state. The <code>action</code> should be safe to call from any execution context.</p><p><code>try_attach sue action</code> must be called at most once per single use event <code>sue</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-try_unattach"><a href="#val-try_unattach" class="anchor"></a><code><span><span class="keyword">val</span> try_unattach : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>try_unattach sue</code> tries to set the single use event <code>sue</code> to the signaled state, which can only succeed if <code>sue</code> was in the attached state.</p><p><code>try_unattach sue</code> may only be called after <code>try_attach sue action</code> has been called successfully on the single use event <code>sue</code>.</p></div></div></div></body></html>